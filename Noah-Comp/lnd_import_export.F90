module lnd_import_export

  use ESMF
  use NUOPC
  use ESMF                    , only : ESMF_GridComp, ESMF_State, ESMF_Mesh, ESMF_StateGet
  use ESMF                    , only : ESMF_KIND_R8, ESMF_SUCCESS, ESMF_MAXSTR, ESMF_LOGMSG_INFO
  use ESMF                    , only : ESMF_LogWrite, ESMF_LOGMSG_ERROR, ESMF_LogFoundError, ESMF_FAILURE
  use ESMF                    , only : ESMF_STATEITEM_NOTFOUND, ESMF_StateItem_Flag
  use ESMF                    , only : operator(/=), operator(==)
  use NUOPC                   , only : NUOPC_CompAttributeGet, NUOPC_Advertise, NUOPC_IsConnected
  use NUOPC_Model             , only : NUOPC_ModelGet
  use shr_kind_mod            , only : r8 => shr_kind_r8, cx=>shr_kind_cx, cs=>shr_kind_cs
  use shr_sys_mod             , only : shr_sys_abort
  use clm_varctl              , only : iulog
  ! use clm_time_manager        , only : get_nstep
  ! use decompmod               , only : bounds_type, get_proc_bounds
  ! use lnd2atmType             , only : lnd2atm_type
  ! use lnd2glcMod              , only : lnd2glc_type
  ! use atm2lndType             , only : atm2lnd_type
  ! use glc2lndMod              , only : glc2lnd_type
  ! use domainMod               , only : ldomain
  ! use spmdMod                 , only : masterproc
  ! use seq_drydep_mod          , only : seq_drydep_readnl, n_drydep
  ! use shr_megan_mod           , only : shr_megan_readnl, shr_megan_mechcomps_n
  use nuopc_shr_methods       , only : chkerr
  ! use lnd_import_export_utils , only : check_for_errors, check_for_nans

  implicit none
  private ! except

  public  :: advertise_fields
  public  :: realize_fields
  ! public  :: import_fields
  ! public  :: export_fields

  private :: fldlist_add
  private :: fldlist_realize
  private :: state_getfldptr
  ! private :: fldchk

  type fld_list_type
     character(len=128) :: stdname
     integer :: ungridded_lbound = 0
     integer :: ungridded_ubound = 0
  end type fld_list_type

  integer, parameter     :: fldsMax = 100
  integer                :: fldsToLnd_num = 0
  integer                :: fldsFrLnd_num = 0
  type (fld_list_type)   :: fldsToLnd(fldsMax)
  type (fld_list_type)   :: fldsFrLnd(fldsMax)

  ! from atm->lnd
  integer                :: ndep_nflds       ! number  of nitrogen deposition fields from atm->lnd/ocn

  ! from lnd->atm
  character(len=cx)      :: carma_fields     ! List of CARMA fields from lnd->atm
  integer                :: drydep_nflds     ! number of dry deposition velocity fields lnd-> atm
  integer                :: megan_nflds      ! number of MEGAN voc fields from lnd-> atm
  integer                :: emis_nflds       ! number of fire emission fields from lnd-> atm

  logical                :: flds_co2a        ! use case
  logical                :: flds_co2b        ! use case
  logical                :: flds_co2c        ! use case
  integer                :: glc_nec          ! number of glc elevation classes
  integer, parameter     :: debug = 0        ! internal debug level

  ! import fields
  character(*), parameter :: Faxa_lwdn           = 'Faxa_lwdn'
  character(*), parameter :: inst_land_sea_mask  = 'inst_land_sea_mask'
  character(*), parameter :: foo_atm2lndfield    = 'foo_atm2lndfield'
  character(*), parameter :: Faxa_swndr          = 'Faxa_swndr'
  character(*), parameter :: Faxa_swvdr          = 'Faxa_swvdr'
  character(*), parameter :: Faxa_swndf          = 'Faxa_swndf'
  character(*), parameter :: Faxa_swvdf          = 'Faxa_swvdf'
  character(*), parameter :: Faxa_rain           = 'Faxa_rain'
  character(*), parameter :: Faxa_snow           = 'Faxa_snow'
  character(*), parameter :: land_mask           = 'land_mask'
  character(*), parameter :: sea_surface_temperature  = 'sea_surface_temperature'

  character(*), parameter :: Faxa_soiltyp   = 'Faxa_soiltyp'
  character(*), parameter :: Faxa_vegtype   = 'Faxa_vegtype'
  character(*), parameter :: Faxa_sigmaf    = 'Faxa_sigmaf'
  character(*), parameter :: Faxa_sfcemis   = 'Faxa_sfcemis'
  character(*), parameter :: Faxa_dlwflx    = 'Faxa_dlwflx'
  character(*), parameter :: Faxa_dswsfc    = 'Faxa_dswsfc'
  character(*), parameter :: inst_down_sw_flx = 'inst_down_sw_flx'
  character(*), parameter :: Faxa_snet      = 'Faxa_snet'
  character(*), parameter :: Faxa_tg3       = 'Faxa_tg3'
  character(*), parameter :: Faxa_cm        = 'Faxa_cm'
  character(*), parameter :: Faxa_ch        = 'Faxa_ch'
  character(*), parameter :: Faxa_prsl1     = 'Faxa_prsl1'
  character(*), parameter :: Faxa_prslki    = 'Faxa_prslki'
  character(*), parameter :: Faxa_zf        = 'Faxa_zf'
  character(*), parameter :: Faxa_land      = 'Faxa_land'
  character(*), parameter :: Faxa_slopetyp  = 'Faxa_slopetyp'
  character(*), parameter :: Faxa_shdmin    = 'Faxa_shdmin'
  character(*), parameter :: Faxa_shdmax    = 'Faxa_shdmax'
  character(*), parameter :: Faxa_snoalb    = 'Faxa_snoalb'
  character(*), parameter :: Faxa_sfalb     = 'Faxa_sfalb'
  character(*), parameter :: Faxa_bexppert  = 'Faxa_bexppert'
  character(*), parameter :: Faxa_xlaipert  = 'Faxa_xlaipert'
  character(*), parameter :: Faxa_vegfpert  = 'Faxa_vegfpert'
  character(*), parameter :: Faxa_prsik1    = 'Faxa_prsik1'
  character(*), parameter :: Faxa_weasd     = 'Faxa_weasd'
  character(*), parameter :: Faxa_snwdph    = 'Faxa_snwdph'
  character(*), parameter :: Faxa_tskin     = 'Faxa_tskin'
  character(*), parameter :: Faxa_tprcp     = 'Faxa_tprcp'
  character(*), parameter :: Faxa_srflag    = 'Faxa_srflag'
  ! character(*), parameter :: Faxa_smc       = 'Faxa_smc'
  ! character(*), parameter :: Faxa_stc       = 'Faxa_stc'
  ! character(*), parameter :: Faxa_slc       = 'Faxa_slc'
  character(*), parameter :: Faxa_canopy    = 'Faxa_canopy'
  character(*), parameter :: Faxa_trans     = 'Faxa_trans'
  character(*), parameter :: Faxa_tsurf     = 'Faxa_tsurf'
  character(*), parameter :: Faxa_z0rl      = 'Faxa_z0rl'
  character(*), parameter :: Faxa_z0pert    = 'Faxa_z0pert'
  character(*), parameter :: Faxa_ztpert    = 'Faxa_ztpert'
  character(*), parameter :: Faxa_ustar     = 'Faxa_ustar'  
  character(*), parameter :: Faxa_wind      = 'Faxa_wind'
  character(*), parameter :: Faxa_ps        = 'Faxa_ps'
  character(*), parameter :: Faxa_t1        = 'Faxa_t1'
  character(*), parameter :: Faxa_q1        = 'Faxa_q1'
  
  ! export fields
  character(*), parameter :: Sl_lfrin         = 'Sl_lfrin'
  character(*), parameter :: foo_lnd2atmfield = 'foo_lnd2atmfield'
  ! inouts
  character(*), parameter :: Fall_weasd  = 'Fall_weasd'
  character(*), parameter :: Fall_snwdph = 'Fall_snwdph'
  character(*), parameter :: Fall_tskin  = 'Fall_tskin'
  character(*), parameter :: Fall_tprcp  = 'Fall_tprcp'
  character(*), parameter :: Fall_srflag = 'Fall_srflag'
  character(*), parameter :: Fall_smc    = 'Fall_smc'
  character(*), parameter :: Fall_stc    = 'Fall_stc'
  character(*), parameter :: Fall_slc    = 'Fall_slc'
  character(*), parameter :: Fall_canopy = 'Fall_canopy'
  character(*), parameter :: Fall_trans  = 'Fall_trans'
  character(*), parameter :: Fall_tsurf  = 'Fall_tsurf'
  character(*), parameter :: Fall_z0rl   = 'Fall_z0rl'

  ! noahouts
  character(*), parameter :: Fall_sncovr1 = 'Fall_sncovr1'
  character(*), parameter :: Fall_qsurf   = 'Fall_qsurf'
  character(*), parameter :: Fall_gflux   = 'Fall_gflux'
  character(*), parameter :: Fall_drain   = 'Fall_drain'
  character(*), parameter :: Fall_evap    = 'Fall_evap'
  character(*), parameter :: Fall_hflx    = 'Fall_hflx'
  character(*), parameter :: Fall_ep      = 'Fall_ep'
  character(*), parameter :: Fall_runoff  = 'Fall_runoff'
  character(*), parameter :: Fall_cmm     = 'Fall_cmm'
  character(*), parameter :: Fall_chh     = 'Fall_chh'
  character(*), parameter :: Fall_evbs    = 'Fall_evbs'
  character(*), parameter :: Fall_evcw    = 'Fall_evcw'
  character(*), parameter :: Fall_sbsno   = 'Fall_sbsno'
  character(*), parameter :: Fall_snowc   = 'Fall_snowc'
  character(*), parameter :: Fall_stm     = 'Fall_stm'
  character(*), parameter :: Fall_snohf   = 'Fall_snohf'
  character(*), parameter :: Fall_smcwlt2 = 'Fall_smcwlt2'
  character(*), parameter :: Fall_smcref2 = 'Fall_smcref2'
  character(*), parameter :: Fall_wet1    = 'Fall_wet1'

  ! diffouts
  character(*), parameter :: Fall_rb_lnd   = 'Fall_rb_lnd'
  character(*), parameter :: Fall_fm_lnd   = 'Fall_fm_lnd'
  character(*), parameter :: Fall_fh_lnd   = 'Fall_fh_lnd'
  character(*), parameter :: Fall_fm10_lnd = 'Fall_fm10_lnd'
  character(*), parameter :: Fall_fh2_lnd  = 'Fall_fh2_lnd'
  character(*), parameter :: Fall_stress   = 'Fall_stress'


  logical :: send_to_atm = .false.

  character(*),parameter :: F01 = "('(lnd_import_export) ',a,i5,2x,i5,2x,d21.14)"
  character(*),parameter :: u_FILE_u = &
       __FILE__

!===============================================================================
contains
!===============================================================================

!  subroutine advertise_fields(gcomp, flds_scalar_name, glc_present, cism_evolve, rof_prognostic, atm_prognostic, rc)
  subroutine advertise_fields(gcomp, flds_scalar_name,  rc)

    ! use shr_carma_mod     , only : shr_carma_readnl
    ! use shr_ndep_mod      , only : shr_ndep_readnl
    ! use shr_fire_emis_mod , only : shr_fire_emis_readnl
    ! use clm_varctl        , only : ndep_from_cpl

    ! input/output variables
    type(ESMF_GridComp)            :: gcomp
    character(len=*) , intent(in)  :: flds_scalar_name
    ! logical          , intent(in)  :: glc_present
    ! logical          , intent(in)  :: cism_evolve
    ! logical          , intent(in)  :: rof_prognostic
    ! logical          , intent(in)  :: atm_prognostic
    integer          , intent(out) :: rc

    ! local variables
    type(ESMF_State)       :: importState
    type(ESMF_State)       :: exportState
    character(ESMF_MAXSTR) :: cvalue
    integer                :: n, num
    character(len=*), parameter :: subname='(lnd_import_export:advertise_fields)'
    !-------------------------------------------------------------------------------

    rc = ESMF_SUCCESS

    call NUOPC_ModelGet(gcomp, importState=importState, exportState=exportState, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return

    !--------------------------------
    ! determine necessary toggles for below
    !--------------------------------

    ! if (atm_prognostic) then
    !    send_to_atm = .true.
    ! else
    !    send_to_atm = .false.
    ! end if
    ! for now always send to atm
    send_to_atm = .true.

    ! call NUOPC_CompAttributeGet(gcomp, name='flds_co2a', value=cvalue, rc=rc)
    ! if (ChkErr(rc,__LINE__,u_FILE_u)) return
    ! read(cvalue,*) flds_co2a
    ! call ESMF_LogWrite('flds_co2a = '// trim(cvalue), ESMF_LOGMSG_INFO)

    ! call NUOPC_CompAttributeGet(gcomp, name='flds_co2b', value=cvalue, rc=rc)
    ! if (ChkErr(rc,__LINE__,u_FILE_u)) return
    ! read(cvalue,*) flds_co2b
    ! call ESMF_LogWrite('flds_co2b = '// trim(cvalue), ESMF_LOGMSG_INFO)

    ! call NUOPC_CompAttributeGet(gcomp, name='flds_co2c', value=cvalue, rc=rc)
    ! if (ChkErr(rc,__LINE__,u_FILE_u)) return
    ! read(cvalue,*) flds_co2c
    ! call ESMF_LogWrite('flds_co2c = '// trim(cvalue), ESMF_LOGMSG_INFO)

    ! ! Determine  number of elevation classes
    ! call NUOPC_CompAttributeGet(gcomp, name='glc_nec', value=cvalue, rc=rc)
    ! if (ChkErr(rc,__LINE__,u_FILE_u)) return
    ! read(cvalue,*) glc_nec
    ! call ESMF_LogWrite('glc_nec = '// trim(cvalue), ESMF_LOGMSG_INFO)
    ! if (glc_nec < 1) then
    !    call shr_sys_abort('ERROR: In CLM4.5 and later, glc_nec must be at least 1.')
    ! end if

    !--------------------------------
    ! Advertise export fields
    !--------------------------------

    ! ! The following namelist reads should always be called regardless of the send_to_atm value

    ! ! Dry Deposition velocities from land - ALSO initialize drydep here
    ! call seq_drydep_readnl("drv_flds_in", drydep_nflds)

    ! ! Fire emissions fluxes from land
    ! call shr_fire_emis_readnl('drv_flds_in', emis_nflds)

    ! ! MEGAN VOC emissions fluxes from land
    ! call shr_megan_readnl('drv_flds_in', megan_nflds)
    ! if (shr_megan_mechcomps_n .ne. megan_nflds) call shr_sys_abort('ERROR: megan field count mismatch')

    ! ! CARMA volumetric soil water from land
    ! ! TODO: is the following correct - the CARMA field exchange is very confusing in mct
    ! call shr_carma_readnl('drv_flds_in', carma_fields)

    ! export to atm
    if (send_to_atm) then
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Sl_lfrin     )

       call fldlist_add(fldsFrLnd_num, fldsFrLnd, foo_lnd2atmfield    )
       ! inouts
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_weasd       )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_snwdph      )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_tskin       )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_tprcp       )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_srflag      )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_smc         )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_stc         )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_slc         )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_canopy      )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_trans       )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_tsurf       )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_z0rl        )

       ! noahouts
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_sncovr1      )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_qsurf        )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_gflux        )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_drain        )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_evap         )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_hflx         )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_ep           )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_runoff       )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_cmm          )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_chh          )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_evbs         )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_evcw         )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_sbsno        )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_snowc        )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_stm          )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_snohf        )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_smcwlt2      )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_smcref2      )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_wet1         )

       ! diffouts
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_rb_lnd        )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_fm_lnd        )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_fh_lnd        )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_fm10_lnd      )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_fh2_lnd       )
       call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_stress        )
       
       ! ! call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_methane  )
       ! ! dust fluxes from land (4 sizes)
       ! call fldlist_add(fldsFrLnd_num, fldsFrLnd, Fall_flxdst, ungridded_lbound=1, ungridded_ubound=4)
       ! if (flds_co2b .or. flds_co2c) then
       !    call fldlist_add(fldsFrLnd_num, fldsFrlnd, Fall_fco2_lnd ) ! co2 fields from land
       ! end if
       ! if (drydep_nflds > 0) then
       !    call fldlist_add(fldsFrLnd_num, fldsFrLnd, Sl_ddvel, ungridded_lbound=1, ungridded_ubound=drydep_nflds)
       ! end if
       ! if (shr_megan_mechcomps_n > 0) then
       !    call fldlist_add(fldsFrLnd_num, fldsFrLnd, Fall_voc, ungridded_lbound=1, ungridded_ubound=megan_nflds)
       ! end if
       ! if (emis_nflds > 0) then
       !    call fldlist_add(fldsFrLnd_num, fldsFrLnd, Fall_fire, ungridded_lbound=1, ungridded_ubound=emis_nflds)
       !    call fldlist_add(fldsFrLnd_num, fldsFrLnd, Sl_fztop)
       ! end if
       ! if (carma_fields /= ' ') then
       !    call fldlist_add(fldsFrLnd_num, fldsFrlnd, Sl_soilw) ! optional for carma
       ! end if
    end if

    ! ! export to rof
    ! if (rof_prognostic) then
    !    call fldlist_add(fldsFrLnd_num, fldsFrlnd, Flrl_rofsur)
    !    call fldlist_add(fldsFrLnd_num, fldsFrlnd, Flrl_rofgwl)
    !    call fldlist_add(fldsFrLnd_num, fldsFrlnd, Flrl_rofsub)
    !    call fldlist_add(fldsFrLnd_num, fldsFrlnd, Flrl_rofi  )
    !    call fldlist_add(fldsFrLnd_num, fldsFrlnd, Flrl_irrig )
    ! end if

    ! ! export to glc
    ! if (glc_present .and. cism_evolve) then
    !    ! lnd->glc states from land all lnd->glc elevation classes (1:glc_nec) plus bare land (index 0).
    !    ! The following puts all of the elevation class fields as an
    !    ! undidstributed dimension in the export state field

    !    call fldlist_add(fldsFrLnd_num, fldsFrLnd, Sl_tsrf_elev  , ungridded_lbound=1, ungridded_ubound=glc_nec+1)
    !    call fldlist_add(fldsFrLnd_num, fldsFrLnd, Sl_topo_elev  , ungridded_lbound=1, ungridded_ubound=glc_nec+1)
    !    call fldlist_add(fldsFrLnd_num, fldsFrLnd, Flgl_qice_elev, ungridded_lbound=1, ungridded_ubound=glc_nec+1)
    ! end if

    ! Now advertise above export fields
    do n = 1,fldsFrLnd_num
       call NUOPC_Advertise(exportState, standardName=fldsFrLnd(n)%stdname, &
            TransferOfferGeomObject='will provide', rc=rc)
       if (ChkErr(rc,__LINE__,u_FILE_u)) return
    enddo

    !--------------------------------
    ! Advertise import fields
    !--------------------------------

    call fldlist_add(fldsToLnd_num, fldsToLnd, trim(flds_scalar_name))

    ! from atm
    call fldlist_add(fldsToLnd_num, fldsToLnd, Faxa_lwdn    )
    call fldlist_add(fldsToLnd_num, fldsToLnd, foo_atm2lndfield    )
    call fldlist_add(fldsToLnd_num, fldsToLnd, inst_land_sea_mask  )
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_swndr)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_swvdr)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_swndf)        
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_swvdf)        
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_rain)          
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_snow)

    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_soiltyp)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_vegtype)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_sigmaf)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_sfcemis)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_dlwflx)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_dswsfc)
    call fldlist_add(fldsToLnd_num, fldsToLnd,inst_down_sw_flx)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_snet)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_tg3)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_cm)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_ch)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_prsl1)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_prslki)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_zf)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_land)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_slopetyp)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_shdmin)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_shdmax)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_snoalb)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_sfalb)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_bexppert)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_xlaipert)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_vegfpert)
    
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_prsik1)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_weasd )
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_snwdph)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_tskin )
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_tprcp )
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_srflag)
    ! ! call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_smc   )
    ! ! call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_stc   )
    ! ! call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_slc   )
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_canopy)
    ! call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_trans )
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_tsurf )
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_z0rl  ) 
    ! call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_z0pert) !!
    ! call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_ztpert)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_ustar )    
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_wind)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_ps)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_t1)
    call fldlist_add(fldsToLnd_num, fldsToLnd,Faxa_q1)
    ! call fldlist_add(fldsToLnd_num, fldsToLnd,land_mask)          
    ! call fldlist_add(fldsToLnd_num, fldsToLnd,sea_surface_temperature)


    
    ! ! from atm - black carbon deposition fluxes (3)
    ! ! (1) => bcphidry, (2) => bcphodry, (3) => bcphiwet
    ! call fldlist_add(fldsToLnd_num, fldsToLnd, Faxa_bcph,  ungridded_lbound=1, ungridded_ubound=3)

    ! ! from atm - organic carbon deposition fluxes (3)
    ! ! (1) => ocphidry, (2) => ocphodry, (3) => ocphiwet
    ! call fldlist_add(fldsToLnd_num, fldsToLnd, Faxa_ocph,  ungridded_lbound=1, ungridded_ubound=3)

    ! ! from atm - wet dust deposition frluxes (4 sizes)
    ! ! (1) => dstwet1, (2) => dstwet2, (3) => dstwet3, (4) => dstwet4
    ! call fldlist_add(fldsToLnd_num, fldsToLnd, Faxa_dstwet, ungridded_lbound=1, ungridded_ubound=4)

    ! ! from - atm dry dust deposition frluxes (4 sizes)
    ! call fldlist_add(fldsToLnd_num, fldsToLnd, Faxa_dstdry, ungridded_lbound=1, ungridded_ubound=4)

    ! ! from atm - nitrogen deposition
    ! call shr_ndep_readnl("drv_flds_in", ndep_nflds)
    ! if (ndep_nflds > 0) then
    !    call fldlist_add(fldsToLnd_num, fldsToLnd, Faxa_ndep, ungridded_lbound=1, ungridded_ubound=ndep_nflds)
    !    ! This sets a variable in clm_varctl
    !    ndep_from_cpl = .true.
    ! end if

    ! ! from atm - co2 exchange scenarios
    ! if (flds_co2a .or. flds_co2b .or. flds_co2c) then
    !    call fldlist_add(fldsToLnd_num, fldsToLnd, Sa_co2prog)
    !    call fldlist_add(fldsToLnd_num, fldsToLnd, Sa_co2diag)
    ! end if

    ! if (rof_prognostic) then
    !    ! from river
    !    call fldlist_add(fldsToLnd_num, fldsToLnd, Flrr_flood   )
    !    call fldlist_add(fldsToLnd_num, fldsToLnd, Flrr_volr    )
    !    call fldlist_add(fldsToLnd_num, fldsToLnd, Flrr_volrmch )
    ! end if

    ! if (glc_present) then
    !    ! from land-ice (glc) - no elevation classes
    !    call fldlist_add(fldsToLnd_num, fldsToLnd, Sg_icemask               ) ! mask of where cism is running
    !    call fldlist_add(fldsToLnd_num, fldsToLnd, Sg_icemask_coupled_fluxes) !

    !    ! from land-ice (glc) - fields for all glc->lnd elevation classes (1:glc_nec) plus bare land (index 0)
    !    call fldlist_add(fldsToLnd_num, fldsToLnd, Sg_ice_covered_elev, ungridded_lbound=1, ungridded_ubound=glc_nec+1)
    !    call fldlist_add(fldsToLnd_num, fldsToLnd, Sg_topo_elev       , ungridded_lbound=1, ungridded_ubound=glc_nec+1)

    !    !current not used - but could be used in the future
    !    !call fldlist_add(fldsToLnd_num, fldsToLnd, Flgg_hflx_elev    , ungridded_lbound=1, ungridded_ubound=glc_nec+1)
    ! end if

    ! Now advertise import fields
    do n = 1,fldsToLnd_num
       call NUOPC_Advertise(importState, standardName=fldsToLnd(n)%stdname, &
            TransferOfferGeomObject='will provide', rc=rc)
       if (ChkErr(rc,__LINE__,u_FILE_u)) return
    enddo

  end subroutine advertise_fields

  !===============================================================================
  subroutine realize_fields(gcomp, mesh, grid, flds_scalar_name, flds_scalar_num, rc)

    use ESMF, only : ESMF_Mesh, ESMF_Grid
    
    ! input/output variables
    type(ESMF_GridComp) , intent(inout)          :: gcomp
    type(ESMF_Mesh)     , optional , intent(in)  :: mesh
    type(ESMF_Grid)     , optional , intent(in)  :: grid
    
    character(len=*)    , intent(in)             :: flds_scalar_name
    integer             , intent(in)             :: flds_scalar_num
    integer             , intent(out)            :: rc

    ! local variables
    type(ESMF_State)     :: importState
    type(ESMF_State)     :: exportState
    character(len=*), parameter :: subname='(lnd_import_export:realize_fields)'
    !---------------------------------------------------------------------------

    rc = ESMF_SUCCESS

    call NUOPC_ModelGet(gcomp, importState=importState, exportState=exportState, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return


    if (present(mesh)) then
       call fldlist_realize( &
            state=ExportState, &
            fldList=fldsFrLnd, &
            numflds=fldsFrLnd_num, &
            flds_scalar_name=flds_scalar_name, &
            flds_scalar_num=flds_scalar_num, &
            tag=subname//':Land Export',&
            mesh=mesh, rc=rc)
       if (ChkErr(rc,__LINE__,u_FILE_u)) return

       call fldlist_realize( &
            state=importState, &
            fldList=fldsToLnd, &
            numflds=fldsToLnd_num, &
            flds_scalar_name=flds_scalar_name, &
            flds_scalar_num=flds_scalar_num, &
            tag=subname//':Land Import',&
            mesh=mesh, rc=rc)
       if (ChkErr(rc,__LINE__,u_FILE_u)) return
       
    else if (present(grid)) then
       call fldlist_realize( &
            state=ExportState, &
            fldList=fldsFrLnd, &
            numflds=fldsFrLnd_num, &
            flds_scalar_name=flds_scalar_name, &
            flds_scalar_num=flds_scalar_num, &
            tag=subname//':Land Export',&
            grid=grid, rc=rc)
       if (ChkErr(rc,__LINE__,u_FILE_u)) return

       call fldlist_realize( &
            state=importState, &
            fldList=fldsToLnd, &
            numflds=fldsToLnd_num, &
            flds_scalar_name=flds_scalar_name, &
            flds_scalar_num=flds_scalar_num, &
            tag=subname//':Land Import',&
            grid=grid, rc=rc)
       if (ChkErr(rc,__LINE__,u_FILE_u)) return
    end if
  end subroutine realize_fields

  !===============================================================================
  ! subroutine import_fields( gcomp, bounds, glc_present, rof_prognostic, &
  !      atm2lnd_inst, glc2lnd_inst, wateratm2lndbulk_inst, rc)

  !   !---------------------------------------------------------------------------
  !   ! Convert the input data from the mediator to the land model
  !   !---------------------------------------------------------------------------

  !   use clm_varctl              , only: co2_type, co2_ppmv, use_c13, ndep_from_cpl
  !   use clm_varcon              , only: rair, o2_molar_const, c13ratio
  !   use shr_const_mod           , only: SHR_CONST_TKFRZ
  !   use Wateratm2lndBulkType    , only: wateratm2lndbulk_type
  !   use QSatMod                 , only: QSat
  !   use lnd_import_export_utils , only: derive_quantities, check_for_errors

  !   ! input/output variabes
  !   type(ESMF_GridComp)                         :: gcomp
  !   type(bounds_type)           , intent(in)    :: bounds         ! bounds
  !   logical                     , intent(in)    :: glc_present    ! .true. => running with a non-stub GLC model
  !   logical                     , intent(in)    :: rof_prognostic ! .true. => running with a prognostic ROF model
  !   type(atm2lnd_type)          , intent(inout) :: atm2lnd_inst   ! clm internal input data type
  !   type(glc2lnd_type)          , intent(inout) :: glc2lnd_inst   ! clm internal input data type
  !   type(Wateratm2lndbulk_type) , intent(inout) :: wateratm2lndbulk_inst
  !   integer                     , intent(out)   :: rc

  !   ! local variables
  !   type(ESMF_State)          :: importState
  !   type(ESMF_StateItem_Flag) :: itemFlag
  !   real(r8), pointer         :: dataPtr(:)
  !   real(r8), pointer         :: fldPtr1d(:)
  !   real(r8), pointer         :: fldPtr2d(:,:)
  !   character(len=CS)         :: fldname
  !   integer                   :: num
  !   integer                   :: begg, endg ! bounds
  !   integer                   :: g,i,k,n    ! indices
  !   real(r8)                  :: qsat_kg_kg ! saturation specific humidity (kg/kg)
  !   real(r8)                  :: forc_pbot  ! atmospheric pressure (Pa)
  !   real(r8)                  :: co2_ppmv_input(bounds%begg:bounds%endg)   ! temporary
  !   real(r8)                  :: forc_ndep(bounds%begg:bounds%endg,2)
  !   real(r8)                  :: forc_rainc(bounds%begg:bounds%endg) ! rainxy Atm flux mm/s
  !   real(r8)                  :: forc_rainl(bounds%begg:bounds%endg) ! rainxy Atm flux mm/s
  !   real(r8)                  :: forc_snowc(bounds%begg:bounds%endg) ! snowfxy Atm flux  mm/s
  !   real(r8)                  :: forc_snowl(bounds%begg:bounds%endg) ! snowfxl Atm flux  mm/s
  !   real(r8)                  :: forc_noy(bounds%begg:bounds%endg)
  !   real(r8)                  :: forc_nhx(bounds%begg:bounds%endg)
  !   real(r8)                  :: frac_grc(bounds%begg:bounds%endg, 0:glc_nec)
  !   real(r8)                  :: topo_grc(bounds%begg:bounds%endg, 0:glc_nec)
  !   real(r8)                  :: hflx_grc(bounds%begg:bounds%endg, 0:glc_nec)
  !   real(r8)                  :: icemask_grc(bounds%begg:bounds%endg)
  !   real(r8)                  :: icemask_coupled_fluxes_grc(bounds%begg:bounds%endg)
  !   character(len=*), parameter :: subname='(lnd_import_export:import_fields)'
  !   !---------------------------------------------------------------------------

  !   rc = ESMF_SUCCESS
  !   call ESMF_LogWrite(subname//' called', ESMF_LOGMSG_INFO)

  !   ! Get import state
  !   call NUOPC_ModelGet(gcomp, importState=importState, rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return

  !   ! Set bounds
  !   begg = bounds%begg; endg=bounds%endg

  !   ! Note: precipitation fluxes received  from the coupler
  !   ! are in units of kg/s/m^2. To convert these precipitation rates
  !   ! in units of mm/sec, one must divide by 1000 kg/m^3 and multiply
  !   ! by 1000 mm/m resulting in an overall factor of unity.
  !   ! Below the units are therefore given in mm/s.

  !   ! Required atm input fields
  !   call state_getimport_1d(importState, Sa_z      , atm2lnd_inst%forc_hgt_grc(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Sa_topo   , atm2lnd_inst%forc_topo_grc(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Sa_u      , atm2lnd_inst%forc_u_grc(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Sa_v      , atm2lnd_inst%forc_v_grc(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Sa_shum   , wateratm2lndbulk_inst%forc_q_not_downscaled_grc(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Sa_ptem   , atm2lnd_inst%forc_th_not_downscaled_grc(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Sa_pbot   , atm2lnd_inst%forc_pbot_not_downscaled_grc(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Sa_tbot   , atm2lnd_inst%forc_t_not_downscaled_grc(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Faxa_rainc, forc_rainc(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Faxa_rainl, forc_rainl(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Faxa_snowc, forc_snowc(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Faxa_snowl, forc_snowl(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Faxa_lwdn , atm2lnd_inst%forc_lwrad_not_downscaled_grc(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Faxa_swvdr, atm2lnd_inst%forc_solad_grc(begg:,1), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Faxa_swndr, atm2lnd_inst%forc_solad_grc(begg:,2), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Faxa_swvdf, atm2lnd_inst%forc_solai_grc(begg:,1), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   call state_getimport_1d(importState, Faxa_swndf, atm2lnd_inst%forc_solai_grc(begg:,2), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return

  !   ! optional atm input fields
  !   if (fldchk(importState, Faxa_bcph)) then
  !      ! 1 = bcphidry, 2 = bcphodry, 3 = bcphiwet
  !      call state_getimport_2d(importState, Faxa_bcph, atm2lnd_inst%forc_aer_grc(begg:,1:3), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if
  !   if (fldchk(importState, Faxa_ocph)) then
  !      ! 4 = ocphidry, 5 = ocphodry, 6 = ocphiwet
  !      call state_getimport_2d(importState, Faxa_ocph, atm2lnd_inst%forc_aer_grc(begg:,4:6), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if
  !   if (fldchk(importState, Faxa_dstwet)) then
  !      ! 7 = dstwet1, 9 = dstwet2, 11 = dstwet3, 13 = dstwet4
  !      call state_getimport_2d(importState, Faxa_dstwet, atm2lnd_inst%forc_aer_grc(begg:,7:13:2), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if
  !   if (fldchk(importState, Faxa_dstdry)) then
  !      ! 8 = dstdry1, 10 = dstdry2, 12 = dstdry3, 14 = dstdry4
  !      call state_getimport_2d(importState, Faxa_dstdry, atm2lnd_inst%forc_aer_grc(begg:,8:14:2), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if
  !   if (fldchk(importState, Sa_methane)) then
  !      call state_getimport_1d(importState, Sa_methane, atm2lnd_inst%forc_pch4_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if
  !   if (fldchk(importState, Faxa_ndep)) then
  !      ! The mediator is sending ndep in units if kgN/m2/s - and ctsm
  !      ! uses units of gN/m2/sec so the following conversion needs to happen
  !      call state_getimport_2d(importState, Faxa_ndep, forc_ndep(begg:,:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      do g = begg, endg
  !         atm2lnd_inst%forc_ndep_grc(g) = (forc_ndep(g,1) + forc_ndep(g,2))*1000._r8
  !      end do
  !   end if

  !   ! Atmosphere co2
  !   ! Set default value to a constant and overwrite for prognostic and diagnostic
  !   do g = begg,endg
  !      co2_ppmv_input(g) = co2_ppmv
  !   end do
  !   if (co2_type == 'prognostic') then
  !      fldName = Sa_co2prog
  !      call ESMF_StateGet(importState, trim(fldname), itemFlag, rc=rc)
  !      if ( ChkErr(rc,__LINE__,u_FILE_u)) return
  !      if (itemflag == ESMF_STATEITEM_NOTFOUND .and. co2_type == 'prognostic') then
  !         call shr_sys_abort( subname//' ERROR: must have Sa_co2prog in import state if co2_type is prognostic' )
  !      end if
  !      if (itemflag /= ESMF_STATEITEM_NOTFOUND) then
  !         call state_getfldptr(importState, trim(fldname), dataPtr, rc=rc )
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !         do g = begg,endg
  !            co2_ppmv_input(g) = dataPtr(g-begg+1)   ! co2 atm prognostic
  !         end do
  !      end if
  !   else if (co2_type == 'diagnostic') then
  !      fldName = Sa_co2diag
  !      call ESMF_StateGet(importState, trim(fldname), itemFlag, rc=rc)
  !      if ( ChkErr(rc,__LINE__,u_FILE_u)) return
  !      if (itemflag == ESMF_STATEITEM_NOTFOUND .and. co2_type == 'diagnostic') then
  !         call shr_sys_abort( subname//' ERROR: must have Sa_co2diag in import state if co2_type equal diagnostic')
  !      end if
  !      if (itemflag /= ESMF_STATEITEM_NOTFOUND) then
  !         call state_getfldptr(importState, trim(fldname), dataPtr, rc=rc )
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !         do g = begg,endg
  !            co2_ppmv_input(g) = dataPtr(g-begg+1)   ! co2 atm diagnostic
  !         end do
  !      end if
  !   end if

  !   ! Note that the following does unit conversions from ppmv to partial pressures (Pa)
  !   ! Note that forc_pbot is in Pa
  !   do g = begg,endg
  !      forc_pbot = atm2lnd_inst%forc_pbot_not_downscaled_grc(g)
  !      atm2lnd_inst%forc_pco2_grc(g) = co2_ppmv_input(g) * 1.e-6_r8 * forc_pbot
  !   end do
  !   if (use_c13) then
  !      do g = begg,endg
  !         forc_pbot = atm2lnd_inst%forc_pbot_not_downscaled_grc(g)
  !         atm2lnd_inst%forc_pc13o2_grc(g) = co2_ppmv_input(g) * c13ratio * 1.e-6_r8 * forc_pbot
  !      end do
  !   end if

  !   ! Flooding from river
  !   ! sign convention is positive downward and hierarchy is atm/glc/lnd/rof/ice/ocn.
  !   ! so water sent from rof to land is negative,
  !   ! change the sign to indicate addition of water to system.
  !   if (fldchk(importState, Flrr_flood)) then
  !      call state_getimport_1d(importState, Flrr_flood, wateratm2lndbulk_inst%forc_flood_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      do g = begg, endg
  !         wateratm2lndbulk_inst%forc_flood_grc(g) = wateratm2lndbulk_inst%forc_flood_grc(g) * (ldomain%area(g) * 1.e6_r8)
  !      end do
  !   else
  !      wateratm2lndbulk_inst%forc_flood_grc(:) = 0._r8
  !   end if
  !   if (fldchk(importState, Flrr_volr)) then
  !      call state_getimport_1d(importState, Flrr_volr, wateratm2lndbulk_inst%volr_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      do g = begg, endg
  !         wateratm2lndbulk_inst%volr_grc(g) = wateratm2lndbulk_inst%volr_grc(g) * (ldomain%area(g) * 1.e6_r8)
  !      end do
  !   else
  !      wateratm2lndbulk_inst%volr_grc(:) = 0._r8
  !   end if
  !   if (fldchk(importState, Flrr_volrmch)) then
  !      call state_getimport_1d(importState, Flrr_volrmch, wateratm2lndbulk_inst%volrmch_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      do g = begg, endg
  !         wateratm2lndbulk_inst%volrmch_grc(g) = wateratm2lndbulk_inst%volrmch_grc(g) * (ldomain%area(g) * 1.e6_r8)
  !      end do
  !   else
  !      wateratm2lndbulk_inst%volrmch_grc(:) = 0._r8
  !   end if

  !   ! Land-ice (glc) fields
  !   if (glc_present) then
  !      ! We could avoid setting these fields if glc_present is .false., if that would
  !      ! help with performance. (The downside would be that we wouldn't have these fields
  !      ! available for diagnostic purposes or to force a later T compset with dlnd.)

  !      call state_getimport_2d(importState, Sg_ice_covered_elev       , frac_grc(begg:,0:glc_nec), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_getimport_2d(importState, Sg_topo_elev              , topo_grc(begg:,0:glc_nec), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_getimport_1d(importState, Sg_icemask                , icemask_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_getimport_1d(importState, Sg_icemask_coupled_fluxes , icemask_coupled_fluxes_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      if (fldchk(importState, Flgg_hflx_elev)) then
  !         call state_getimport_2d(importState, Flgg_hflx_elev, hflx_grc(begg:,0:glc_nec), rc=rc)
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      else
  !         hflx_grc(:,:) = 0._r8
  !      end if

  !      call glc2lnd_inst%set_glc2lnd_fields_nuopc( bounds, glc_present, &
  !           frac_grc, topo_grc, hflx_grc, icemask_grc, icemask_coupled_fluxes_grc )
  !   end if

  !   !--------------------------
  !   ! Derived quantities for required fields
  !   ! and corresponding error checks
  !   !--------------------------

  !   call derive_quantities(bounds, atm2lnd_inst, wateratm2lndbulk_inst, &
  !      forc_rainc, forc_rainl, forc_snowc, forc_snowl)

  !   call check_for_errors(bounds, atm2lnd_inst, wateratm2lndbulk_inst)

  ! end subroutine import_fields

  ! !===============================================================================
  ! subroutine export_fields( gcomp, bounds, glc_present, rof_prognostic, &
  !      waterlnd2atmbulk_inst, lnd2atm_inst, lnd2glc_inst, rc)

  !   !-------------------------------
  !   ! Pack the export state
  !   ! sign convention is positive downward with hierarchy of atm/glc/lnd/rof/ice/ocn.
  !   ! i.e. water sent from land to rof is positive
  !   !-------------------------------

  !   use Waterlnd2atmBulkType , only: waterlnd2atmbulk_type

  !   ! input/output variables
  !   type(ESMF_GridComp)                         :: gcomp
  !   type(bounds_type)           , intent(in)    :: bounds      
  !   logical                     , intent(in)    :: glc_present
  !   logical                     , intent(in)    :: rof_prognostic
  !   type(waterlnd2atmbulk_type) , intent(inout) :: waterlnd2atmbulk_inst
  !   type(lnd2atm_type)          , intent(inout) :: lnd2atm_inst ! land to atmosphere exchange data type
  !   type(lnd2glc_type)          , intent(inout) :: lnd2glc_inst ! land to atmosphere exchange data type
  !   integer                     , intent(out)   :: rc

  !   ! local variables
  !   type(ESMF_State)  :: exportState
  !   real(r8), pointer :: fldPtr1d(:)
  !   real(r8), pointer :: fldPtr2d(:,:)
  !   character(len=CS) :: fldname
  !   integer           :: begg, endg
  !   integer           :: i, g, num
  !   real(r8)          :: data1d(bounds%begg:bounds%endg)
  !   character(len=*), parameter :: subname='(lnd_import_export:export_fields)'
  !   !---------------------------------------------------------------------------

  !   rc = ESMF_SUCCESS

  !   ! Get export state
  !   call NUOPC_ModelGet(gcomp, exportState=exportState, rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return

  !   ! Set bounds
  !   begg = bounds%begg
  !   endg = bounds%endg

  !   ! -----------------------
  !   ! output to mediator
  !   ! -----------------------

  !   call state_setexport_1d(exportState, Sl_lfrin, ldomain%frac(begg:), rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return

  !   ! -----------------------
  !   ! output to atm
  !   ! -----------------------
  !   if (send_to_atm) then
  !      call state_setexport_1d(exportState, Sl_t      , lnd2atm_inst%t_rad_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Sl_snowh  , waterlnd2atmbulk_inst%h2osno_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Sl_avsdr  , lnd2atm_inst%albd_grc(begg:,1), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Sl_anidr  , lnd2atm_inst%albd_grc(begg:,2), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Sl_avsdf  , lnd2atm_inst%albi_grc(begg:,1), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Sl_anidf  , lnd2atm_inst%albi_grc(begg:,2), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Sl_tref   , lnd2atm_inst%t_ref2m_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Sl_qref   , waterlnd2atmbulk_inst%q_ref2m_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Fall_taux , lnd2atm_inst%taux_grc(begg:), minus=.true., rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Fall_tauy , lnd2atm_inst%tauy_grc(begg:), minus=.true., rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Fall_lat  , lnd2atm_inst%eflx_lh_tot_grc(begg:), minus=.true., rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Fall_sen  , lnd2atm_inst%eflx_sh_tot_grc(begg:), minus=.true., rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Fall_lwup , lnd2atm_inst%eflx_lwrad_out_grc(begg:), minus=.true., rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Fall_evap , waterlnd2atmbulk_inst%qflx_evap_tot_grc(begg:), minus=.true., rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      call state_setexport_1d(exportState, Fall_swnet, lnd2atm_inst%fsa_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return

  !      ! optional fields
  !      if (fldchk(exportState, Fall_flxdst)) then
  !         call state_setexport_2d(exportState, Fall_flxdst, lnd2atm_inst%flxdst_grc(begg:,1:4), &
  !              minus= .true., rc=rc)
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      end if
  !      if (fldchk(exportState, Fall_methane)) then
  !         call state_setexport_1d(exportState, Fall_methane, lnd2atm_inst%ch4_surf_flux_tot_grc(begg:), &
  !              minus=.true., rc=rc)
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      end if
  !      if (fldchk(exportState, Sl_u10)) then
  !         call state_setexport_1d(exportState, Sl_u10, lnd2atm_inst%u_ref10m_grc(begg:), rc=rc)
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      end if
  !      if (fldchk(exportState, Sl_ram1)) then
  !         call state_setexport_1d(exportState, Sl_ram1, lnd2atm_inst%ram1_grc(begg:), rc=rc)
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      end if
  !      if (fldchk(exportState, Sl_fv)) then
  !         call state_setexport_1d(exportState, Sl_fv, lnd2atm_inst%fv_grc(begg:), rc=rc)
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      end if
  !      if (fldchk(exportState, Sl_soilw)) then
  !         call state_setexport_1d(exportState, Sl_soilw, waterlnd2atmbulk_inst%h2osoi_vol_grc(begg:,1), rc=rc)
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      end if
  !      if (fldchk(exportState, Fall_fco2_lnd)) then
  !         call state_setexport_1d(exportState, Fall_fco2_lnd, lnd2atm_inst%net_carbon_exchange_grc(begg:), &
  !              minus=.true., rc=rc)
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      end if
  !      if (fldchk(exportState, Sl_ddvel)) then ! dry dep velocities
  !         call state_setexport_2d(exportState, Sl_ddvel, lnd2atm_inst%ddvel_grc(begg:,1:drydep_nflds), rc=rc)
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      end if
  !      if (fldchk(exportState, Fall_voc)) then ! megan voc emis fluxes
  !         call state_setexport_2d(exportState, Fall_voc, lnd2atm_inst%flxvoc_grc(begg:,1:shr_megan_mechcomps_n), &
  !              minus = .true., rc=rc)
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      end if
  !      if (fldchk(exportState, Fall_fire)) then ! fire emis from land
  !         call state_setexport_2d(exportState, Fall_fire, lnd2atm_inst%fireflx_grc(begg:,1:emis_nflds), &
  !              minus = .true., rc=rc)
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      end if
  !      if (fldchk(exportState, Sl_fztop)) then ! fire emis from land
  !         call state_setexport_1d(exportState, Sl_fztop, lnd2atm_inst%fireztop_grc(begg:), rc=rc)
  !         if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !      end if
  !   endif

  !   ! -----------------------
  !   ! output to river
  !   ! -----------------------
  !   ! surface runoff is the sum of qflx_over, qflx_h2osfc_surf
  !   ! do g = begg,endg
  !   !   data1d(g) = waterlnd2atmbulk_inst%qflx_rofliq_qsur_grc(g) + &
  !   !               waterlnd2atmbulk_inst%qflx_rofliq_h2osfc_grc(g)
  !   ! end do

  !   if (fldchk(exportState, Flrl_rofsur)) then
  !      call state_setexport_1d(exportState, Flrl_rofsur, waterlnd2atmbulk_inst%qflx_rofliq_qsur_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if
  !   if (fldchk(exportState, Flrl_rofgwl)) then ! qgwl sent individually to mediator
  !      call state_setexport_1d(exportState, Flrl_rofgwl, waterlnd2atmbulk_inst%qflx_rofliq_qgwl_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if
  !   if (fldchk(exportState, Flrl_rofi)) then ! ice set individually to mediator
  !      call state_setexport_1d(exportState, Flrl_rofi, waterlnd2atmbulk_inst%qflx_rofice_grc(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if
  !   if (fldchk(exportState, Flrl_irrig)) then ! irrigation flux to be removed from main channel storage (negative)
  !      call state_setexport_1d(exportState, Flrl_irrig, waterlnd2atmbulk_inst%qirrig_grc(begg:), &
  !           minus = .true., rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if
  !   if (fldchk(exportState, Flrl_rofsub)) then
  !      ! subsurface runoff is the sum of qflx_drain and qflx_perched_drain
  !      do g = begg, endg
  !         data1d(g) = waterlnd2atmbulk_inst%qflx_rofliq_qsub_grc(g) + &
  !                     waterlnd2atmbulk_inst%qflx_rofliq_drain_perched_grc(g)
  !      end do
  !      call state_setexport_1d(exportState, Flrl_rofsub, data1d(begg:), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if

  !   ! -----------------------
  !   ! output to glc
  !   ! -----------------------
  !   ! We could avoid setting these fields if glc_present is .false., if that would
  !   ! help with performance. (The downside would be that we wouldn't have these fields
  !   ! available for diagnostic purposes or to force a later T compset with dlnd.)

  !   if (fldchk(exportState, Sl_tsrf_elev)) then
  !      call state_setexport_2d(exportState, Sl_tsrf_elev, lnd2glc_inst%tsrf_grc(begg:,0:glc_nec), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if
  !   if (fldchk(exportState, Sl_topo_elev)) then
  !      call state_setexport_2d(exportState, Sl_topo_elev, lnd2glc_inst%topo_grc(begg:,0:glc_nec), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if
  !   if (fldchk(exportState, Flgl_qice_elev)) then
  !      call state_setexport_2d(exportState, Flgl_qice_elev, lnd2glc_inst%qice_grc(begg:,0:glc_nec), rc=rc)
  !      if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   end if

  ! end subroutine export_fields

  !===============================================================================
  subroutine fldlist_add(num, fldlist, stdname, ungridded_lbound, ungridded_ubound)

    ! input/output variables
    integer,                    intent(inout) :: num
    type(fld_list_type),        intent(inout) :: fldlist(:)
    character(len=*),           intent(in)    :: stdname
    integer,          optional, intent(in)    :: ungridded_lbound
    integer,          optional, intent(in)    :: ungridded_ubound

    ! local variables
    integer :: rc
    character(len=*), parameter :: subname='(lnd_import_export:fldlist_add)'
    !-------------------------------------------------------------------------------

    ! Set up a list of field information

    num = num + 1
    if (num > fldsMax) then
       call ESMF_LogWrite(trim(subname)//": ERROR num > fldsMax "//trim(stdname), &
            ESMF_LOGMSG_ERROR, line=__LINE__, file=__FILE__)
       call shr_sys_abort(trim(subname)//": ERROR: num > fldsMax")
    endif
    fldlist(num)%stdname = trim(stdname)

    if (present(ungridded_lbound) .and. present(ungridded_ubound)) then
       fldlist(num)%ungridded_lbound = ungridded_lbound
       fldlist(num)%ungridded_ubound = ungridded_ubound
    end if

  end subroutine fldlist_add

  !===============================================================================
  subroutine fldlist_realize(state, fldList, numflds, flds_scalar_name, flds_scalar_num, mesh, grid, tag, rc)

    use NUOPC , only : NUOPC_IsConnected, NUOPC_Realize
    use ESMF  , only : ESMF_MeshLoc_Element, ESMF_INDEX_DELOCAL, ESMF_FieldCreate, ESMF_TYPEKIND_R8
    use ESMF  , only : ESMF_MAXSTR, ESMF_Field, ESMF_State, ESMF_Mesh, ESMF_Grid, ESMF_StateRemove
    use ESMF  , only : ESMF_LogFoundError, ESMF_LOGMSG_INFO, ESMF_SUCCESS
    use ESMF  , only : ESMF_LogWrite, ESMF_LOGMSG_ERROR, ESMF_LOGERR_PASSTHRU

    ! input/output variables
    type(ESMF_State)    , intent(inout) :: state
    type(fld_list_type) , intent(in)    :: fldList(:)
    integer             , intent(in)    :: numflds
    character(len=*)    , intent(in)    :: flds_scalar_name
    integer             , intent(in)    :: flds_scalar_num
    character(len=*)    , intent(in)    :: tag
    type(ESMF_Mesh), optional , intent(in)    :: mesh
    type(ESMF_Grid), optional , intent(in)    :: grid
    integer             , intent(inout) :: rc

    ! local variables
    integer                :: n
    type(ESMF_Field)       :: field
    character(len=80)      :: stdname
    character(len=*),parameter  :: subname='(lnd_import_export:fldlist_realize)'
    ! ----------------------------------------------

    rc = ESMF_SUCCESS

    do n = 1, numflds
       stdname = fldList(n)%stdname
       if (NUOPC_IsConnected(state, fieldName=stdname)) then
          if (stdname == trim(flds_scalar_name)) then
             call ESMF_LogWrite(trim(subname)//trim(tag)//" Field = "//trim(stdname)//" is connected on root pe", &
                  ESMF_LOGMSG_INFO)
             ! Create the scalar field
             call SetScalarField(field, flds_scalar_name, flds_scalar_num, rc=rc)
             if (ChkErr(rc,__LINE__,u_FILE_u)) return
          else
             ! Create the field
             if (present(mesh)) then
                if (fldlist(n)%ungridded_lbound > 0 .and. fldlist(n)%ungridded_ubound > 0) then
                   field = ESMF_FieldCreate(mesh, ESMF_TYPEKIND_R8, name=stdname, meshloc=ESMF_MESHLOC_ELEMENT, &
                        ungriddedLbound=(/fldlist(n)%ungridded_lbound/), &
                        ungriddedUbound=(/fldlist(n)%ungridded_ubound/), &
                        gridToFieldMap=(/2/), rc=rc)
                   if (ChkErr(rc,__LINE__,u_FILE_u)) return
                else
                   field = ESMF_FieldCreate(mesh, ESMF_TYPEKIND_R8, name=stdname, meshloc=ESMF_MESHLOC_ELEMENT, rc=rc)
                   if (ChkErr(rc,__LINE__,u_FILE_u)) return
                end if
                call ESMF_LogWrite(trim(subname)//trim(tag)//" Field = "//trim(stdname)//" is connected using mesh", &
                     ESMF_LOGMSG_INFO)
             else if (present(grid)) then
                ! Note no ungridded bounds. Hope this doesn't cause issues.
                   field = ESMF_FieldCreate(grid, ESMF_TYPEKIND_R8, name=stdname, indexflag=ESMF_INDEX_DELOCAL, rc=rc)
                   if (ChkErr(rc,__LINE__,u_FILE_u)) return
                call ESMF_LogWrite(trim(subname)//trim(tag)//" Field = "//trim(stdname)//" is connected using grid", &
                     ESMF_LOGMSG_INFO)
             else
                call ESMF_LogWrite(subname // 'input must be grid or mesh', ESMF_LOGMSG_INFO)
                rc = ESMF_FAILURE
                return
             end if ! mesh or grid
          endif

          ! NOW call NUOPC_Realize
          call NUOPC_Realize(state, field=field, rc=rc)
          if (ChkErr(rc,__LINE__,u_FILE_u)) return
       else
          if (stdname /= trim(flds_scalar_name)) then
             call ESMF_LogWrite(subname // trim(tag) // " Field = "// trim(stdname) // " is not connected.", &
                  ESMF_LOGMSG_INFO)
             call ESMF_StateRemove(state, (/stdname/), rc=rc)
             if (ChkErr(rc,__LINE__,u_FILE_u)) return
          end if
       end if
    end do

  contains  !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    subroutine SetScalarField(field, flds_scalar_name, flds_scalar_num, rc)
      ! ----------------------------------------------
      ! create a field with scalar data on the root pe
      ! ----------------------------------------------
      use ESMF, only : ESMF_Field, ESMF_DistGrid, ESMF_Grid
      use ESMF, only : ESMF_DistGridCreate, ESMF_GridCreate, ESMF_LogFoundError, ESMF_LOGERR_PASSTHRU
      use ESMF, only : ESMF_FieldCreate, ESMF_GridCreate, ESMF_TYPEKIND_R8

      type(ESMF_Field) , intent(inout) :: field
      character(len=*) , intent(in)    :: flds_scalar_name
      integer          , intent(in)    :: flds_scalar_num
      integer          , intent(inout) :: rc

      ! local variables
      type(ESMF_Distgrid) :: distgrid
      type(ESMF_Grid)     :: grid
      character(len=*), parameter :: subname='(lnd_import_export:SetScalarField)'
      ! ----------------------------------------------

      rc = ESMF_SUCCESS

      ! create a DistGrid with a single index space element, which gets mapped onto DE 0.
      distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/1/), rc=rc)
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, line=__LINE__, file=u_FILE_u)) return

      grid = ESMF_GridCreate(distgrid, rc=rc)
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, line=__LINE__, file=u_FILE_u)) return

      field = ESMF_FieldCreate(name=trim(flds_scalar_name), grid=grid, typekind=ESMF_TYPEKIND_R8, &
           ungriddedLBound=(/1/), ungriddedUBound=(/flds_scalar_num/), gridToFieldMap=(/2/), rc=rc)
      if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, line=__LINE__, file=u_FILE_u)) return

    end subroutine SetScalarField

  end subroutine fldlist_realize

  !===============================================================================
  subroutine state_getimport_1d(state, fldname, ctsmdata, rc)

    ! fill in ctsm import data for 1d field

    use ESMF, only : ESMF_LOGERR_PASSTHRU, ESMF_END_ABORT, ESMF_LogFoundError
    use ESMF, only : ESMF_Finalize

    ! input/output variabes
    type(ESMF_State) , intent(in)    :: state
    character(len=*) , intent(in)    :: fldname
    real(r8)         , intent(inout) :: ctsmdata(:)
    integer          , intent(out)   :: rc

    ! local variables
    real(r8), pointer :: fldPtr1d(:)
    integer           :: g
    character(len=*), parameter :: subname='(lnd_import_export:state_getimport_1d)'
    ! ----------------------------------------------

    rc = ESMF_SUCCESS

    call state_getfldptr(State, trim(fldname), fldptr1d=fldptr1d, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    do g = 1,size(ctsmdata)
       ctsmdata(g) = fldptr1d(g)
    end do
    !call check_for_nans(ctsmdata, trim(fldname), 1)

  end subroutine state_getimport_1d

  !===============================================================================
  ! subroutine state_getimport_2d(state, fldname, ctsmdata, rc)

  !   ! fill in ctsm import data for 2d field

  !   use ESMF, only : ESMF_LOGERR_PASSTHRU, ESMF_END_ABORT, ESMF_LogFoundError
  !   use ESMF, only : ESMF_Finalize

  !   ! input/output variabes
  !   type(ESMF_State) , intent(in)    :: state
  !   character(len=*) , intent(in)    :: fldname
  !   real(r8)         , intent(inout) :: ctsmdata(:,:)
  !   integer          , intent(out)   :: rc

  !   ! local variables
  !   real(r8), pointer :: fldPtr2d(:,:)
  !   integer           :: g,n
  !   character(len=CS) :: cnum
  !   character(len=*), parameter :: subname='(lnd_import_export:state_getimport_1d)'
  !   ! ----------------------------------------------

  !   rc = ESMF_SUCCESS

  !   call state_getfldptr(state, trim(fldname), fldptr2d=fldptr2d, rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   do n = 1,size(ctsmdata, dim=2)
  !      write(cnum,'(i0)') n
  !      do g = 1,size(ctsmdata,dim=1)
  !         ctsmdata(g,n) = fldptr2d(n,g)
  !      end do
  !      call check_for_nans(ctsmdata(:,n), trim(fldname)//trim(cnum), 1)
  !   end do

  ! end subroutine state_getimport_2d

  ! !===============================================================================
  ! subroutine state_setexport_1d(state, fldname, ctsmdata, minus, rc)

  !   ! fill in ctsm export data for 1d field

  !   use ESMF, only : ESMF_LOGERR_PASSTHRU, ESMF_END_ABORT, ESMF_LogFoundError
  !   use ESMF, only : ESMF_Finalize

  !   ! input/output variabes
  !   type(ESMF_State) , intent(in) :: state
  !   character(len=*) , intent(in) :: fldname
  !   real(r8)         , intent(in) :: ctsmdata(:)
  !   logical, optional, intent(in) :: minus
  !   integer          , intent(out):: rc

  !   ! local variables
  !   real(r8), pointer :: fldPtr1d(:)
  !   integer           :: g
  !   character(len=*), parameter :: subname='(lnd_export_export:state_setexport_1d)'
  !   ! ----------------------------------------------

  !   call state_getfldptr(state, trim(fldname), fldptr1d=fldptr1d, rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   fldptr1d(:) = 0._r8
  !   if (present(minus)) then
  !      do g = 1,size(ctsmdata)
  !         fldptr1d(g) = -ctsmdata(g)
  !      end do
  !   else
  !      do g = 1,size(ctsmdata)
  !         fldptr1d(g) = ctsmdata(g)
  !      end do
  !   end if
  !   call check_for_nans(ctsmdata, trim(fldname), 1)

  ! end subroutine state_setexport_1d

  ! !===============================================================================
  ! subroutine state_setexport_2d(state, fldname, ctsmdata, minus, rc)

  !   ! fill in ctsm export data for 2d field

  !   use ESMF, only : ESMF_LOGERR_PASSTHRU, ESMF_END_ABORT, ESMF_LogFoundError
  !   use ESMF, only : ESMF_Finalize

  !   ! input/output variabes
  !   type(ESMF_State) , intent(in) :: state
  !   character(len=*) , intent(in) :: fldname
  !   real(r8)         , intent(in) :: ctsmdata(:,:)
  !   logical, optional, intent(in) :: minus
  !   integer          , intent(out):: rc

  !   ! local variables
  !   real(r8), pointer :: fldPtr2d(:,:)
  !   integer           :: g, n
  !   character(len=CS) :: cnum
  !   character(len=*), parameter :: subname='(lnd_export_export:state_setexport_2d)'
  !   ! ----------------------------------------------

  !   rc = ESMF_SUCCESS

  !   call state_getfldptr(state, trim(fldname), fldptr2d=fldptr2d, rc=rc)
  !   if (ChkErr(rc,__LINE__,u_FILE_u)) return
  !   fldptr2d(:,:) = 0._r8
  !   do n = 1,size(ctsmdata, dim=2)
  !      write(cnum,'(i0)') n
  !      if (present(minus)) then
  !         do g = 1,size(ctsmdata, dim=1)
  !            fldptr2d(n,g) = -ctsmdata(g,n)
  !         end do
  !      else
  !         do g = 1,size(ctsmdata, dim=1)
  !            fldptr2d(n,g) = ctsmdata(g,n)
  !         end do
  !      end if
  !      call check_for_nans(ctsmdata(:,n), trim(fldname)//trim(cnum), 1)
  !   end do

  ! end subroutine state_setexport_2d

  !===============================================================================
  subroutine state_getfldptr(State, fldname, fldptr1d, fldptr2d, rc)

    ! ----------------------------------------------
    ! Get pointer to a state field
    ! ----------------------------------------------

    use ESMF , only : ESMF_State, ESMF_Field, ESMF_Mesh, ESMF_FieldStatus_Flag
    use ESMF , only : ESMF_StateGet, ESMF_FieldGet, ESMF_MeshGet
    use ESMF , only : ESMF_FIELDSTATUS_COMPLETE, ESMF_FAILURE

    ! input/output variables
    type(ESMF_State),             intent(in)    :: State
    character(len=*),             intent(in)    :: fldname
    real(R8), pointer, optional , intent(out)   :: fldptr1d(:)
    real(R8), pointer, optional , intent(out)   :: fldptr2d(:,:)
    integer,                      intent(out)   :: rc

    ! local variables
    type(ESMF_FieldStatus_Flag) :: status
    type(ESMF_Field)            :: lfield
    character(len=*), parameter :: subname='(lnd_import_export:state_getfldptr)'
    ! ----------------------------------------------

    rc = ESMF_SUCCESS

    call ESMF_StateGet(State, itemName=trim(fldname), field=lfield, rc=rc)
    if (ChkErr(rc,__LINE__,u_FILE_u)) return
    if (present(fldptr1d)) then
       call ESMF_FieldGet(lfield, farrayPtr=fldptr1d, rc=rc)
       if (ChkErr(rc,__LINE__,u_FILE_u)) return
    else if (present(fldptr2d)) then
       call ESMF_FieldGet(lfield, farrayPtr=fldptr2d, rc=rc)
       if (ChkErr(rc,__LINE__,u_FILE_u)) return
    else
       call shr_sys_abort("either fldptr1d or fldptr2d must be an input argument")
    end if

  end subroutine state_getfldptr

  !===============================================================================
  ! logical function fldchk(state, fldname)
  !   ! ----------------------------------------------
  !   ! Determine if field with fldname is in the input state
  !   ! ----------------------------------------------

  !   ! input/output variables
  !   type(ESMF_State), intent(in)  :: state
  !   character(len=*), intent(in)  :: fldname

  !   ! local variables
  !   type(ESMF_StateItem_Flag)   :: itemFlag
  !   ! ----------------------------------------------
  !   call ESMF_StateGet(state, trim(fldname), itemFlag)
  !   if (itemflag /= ESMF_STATEITEM_NOTFOUND) then
  !      fldchk = .true.
  !   else
  !      fldchk = .false.
  !   endif
  ! end function fldchk

end module lnd_import_export
